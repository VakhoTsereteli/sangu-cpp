# 1. პროგრამის სტრუქტურა.

პროგრამის სტრუქტურა გულისხმობს იმას თუ როგორ არიან პროგრამის სხვადასხვა კომპონენტები განლაგებული 
ჩვენს კოდში, კარგი სტრუქტურა პროგრამაში კრიტიკულია მისი წაკითხვადობის, შენახვისთვის და ადვილად განახლებისთვის. კომპონენტები როგორიცაა:


- import/include:
```cpp
#include<iostream>
#include<string>
```

- სხვა პრეპროცესორის დირექტივები:
```cpp
#pragma once
#define MAX 500
```

- კომენტარები:
```cpp
// ერთხაზიანი კომენტარი

/* მრავალხაზიანი/ბლოკის კომენტარი */
```

- ფუნქციების განცხადება და განმარტება:
```cpp
int multiply(const int& x, const int& y);
//....
int multiply(const int& x, const int& y) {
    return x * y;
}
```

- ცვლადების განცხადება და განმარტება:
```cpp
int num;
num = multiply(4, 5);
```

- პროგრამის მიმართულების კონტროლის სტრუქტურები:
```cpp
if ( num % 2 == 0 ) {
    std::cout << "It's Even!" << std::endl;
} 
else {
    std::cout << "It's Odd" << std::endl;
}
```

- მთავარი ფუნქცია, კოდის შესავალი წერტილი:
```cpp
int main() {
    // კოდი
}
```

# 2. ნაკადების შინაარსი და მაგალითები
ნაკადები C++ - ში არის მონაცემების შეტანა/გამოტანის ფუნდამენტალური სტრუქტურა რომელიც შენახულია <iostream> ბიბლიოთეკაში , ისინი გვეხმარებიან მონაცემების როგორც კონსოლში შეტანა/გამოტანაში(std::cout, std::cin), ასევე ფაილებშიც <fstream> ბიბლიოთეკის დახმარებით (std::ifstream, std::ofstream). მაგალითები:

- `std::ostream` კლასის წევრი `std::cout`
```cpp
#include<iostream>

int main(){
    // დაბეჭდავს "Hello World!"-ს კონსოლში
    std::cout << "Hello World!" << std::endl;
}
```

-  `std::istream` კლასის წევრი `std::cin`
```cpp
#include <iostream>

int main() {
    int input;
    std::cout << "Enter your age: ";
    // გააჩერებს პროგრამას და დაელოდება მომხმარებელს 
    std::cin >> input; // შეინახავს შემოტანილ ინფორმაციას მითითებულ ცვლადში
    std::cout << "You are " << input << " years old" << std::endl;  
}
```

### ფაილებთან სამუშაოდ

- `std::ifstream`
```cpp
#include<iostream>
#include<fstream>

int main() {
    // შევქმნით std::ifstreamis ტიპის ცვლადს
    std::ifstream file;
    file.open("data.txt");

    std::string temp;
    file >> temp;
    
    std::cout << temp;
}
```

- `std::ofstream`
```cpp
#include<iostream>
#include<fstream>

int main() {
    std::ofstream file;
    file.open("data.txt");
    
    file << multiply(4, 5) << std::endl;
}
```

# 3.სტილი კარგი სტილის ზოგიერთი რჩევა(რეკომენდაცია).

კარგი სტილი გულისხმობს სხვადასხვა გზებით კოდის დაფორმატებას და სტრუქტურიზაციას.
ეს აუცილებელია კოდის წაკითხვადობის, ხარისხიანი კოლაბორაციის და განახლების სიადვილისთვის.
მრავალი ერთმანეთისგან განსხვავებული სტილი არსებობს რომელიც გუნდებსა და პროგრამირების
ენებზეა დამოკიდებული, მთავარია ერთმანეთში არ ავურიოთ ისინი. მაგალითები სხვადასხვა სტილის:

- ინდენტაცია
```cpp
int main() {
        // 4 space ინდენტაცია
        std::cout << "Hello World!" << std::endl;
}
```
```cpp
int main() {
    // 4 space ინდენტაცია
    std::cout << "Hello World!" << std::endl;
}
```
```cpp
int main() {
  // 2 space ინდენტაცია
  std::cout << "Hello World!" << std::endl;
}
```

- ბრეკეტების ადგილი
```cpp
int main() {

}
```
```cpp
int main()
{
}
```
```cpp
// მოკლე ფუნქციის შემთხვევაში ზოგი პროგრამისტი ერთ ხაზზეც წერს მათ
int main() {}
```

- სახელების დარქმევა
```cpp
int snake_case;
int camelCase;
int PascalCase;
int kebab-case;

// მუდმივი ცვლადების შემთხვევაში ზოგი პროგრამისტი ასე წერს
const int MAX_LIMIT;
```

- პროექტში ფაილების კარგი ორგანიზაცია

# კომენტარები კოდის ფორმატირება წანაცვლები

კომენტარები ემსახურება კოდის წაკითხვადობას, ხშირად არის კოდის რომელიმე ნაწილი რომელიც
ძნელია გავიგოთ რას შვება, განსაკუთრებით თუ ჩვენი დაწერილი არ არის. ამისთვის არსებობს
კომენტარები, კომპილერი კომენტარებს ყურადღებას არ აქცევს და კოდად არ აღიქვავს. უმეტესობა პროგრამირების ენაში არსებობს ორი ტიპის კომენტარი

- ერთ ხაზიანი კომენტარი
```cpp
int main() {
    int num = 15;
    // std::cout << num << std::endl;
}
```

- ბლოკის კომენტარი
```cpp
int main() {
    int num = 15;
    int num2 = 20;
    /*
        std::cout << num << std::endl;
        std::cout << num2 << std::endl;
    */

}
```

# 5.ცვლადი, მისი მისამართი და სიგრძე.სახელის დარქმევის წესები. ინიციალიზების გზები.

ყველა ცვლადი ინახავს სხვადასხვა მონაცემს ან მონაცემებს, მონაცემი შეიძლება იყოს სხვადასხვა ტიპის
რაც წყვეტს მის ზომას ბაიტებში და შესაბამისად მის სიგრძეს მეხსიერებაში.

ცვლადის ტიპები და მათი ზომები ბაიტებში:

| ტიპი   | მნიშვნელობა 			   | ზომა	  |
|--------|-------------------------|----------|
| int    | მთელი რიცხვი            |	4     |
| float  | ათწილადი    			   |    4     |
| double | ორმაგი სიზუსტის ათწილადი|    8     |
| char   | სიმბოლო                 |    1     |
| bool   | ბულეანი                 |    1     |


სახელს როცა ვარქმევთ ცვლადებს უნდა გავითვალისწინოთ რო მისი სახელი კარგად უნდა
აღწერდეს მის დანიშნულებას კოდში. სახელები როგორიც x, y და n არაფრის მანიშნებელია მაგრამ
თუ მაგალითად სახელი იქნება person\_age, max\_limit ან first_name უკვე აშკარაა რას ინახავენ ეს ცვლადები

ცვლადების ინიციალიზაციის სხვადასხვა გზა არსებობს, ყველა სიტუაციურია, მაგალითად:
```cpp
int main() {
    // დეკლარაციის დროს ინიციალიზაცია
    int a = 4;
    
    // დეკლარაცია და მოგვიანებით ინიციალიზაცია
    int b;
    b = 10;
    
    // Default ინიციალიზაცია
    int c{};
}
```

# 6. რეფერენსი

რეფერენსი არის იგივე ცვლადისთვის ალტერნატიული სახლელის შექმნა, როცა რეფერენსი არის ინიციალიზირებული ნებისმიერი ცვლილება რეფერენსზე აისახება ორიგინალ ცვლადზეც და პირიქით.

```cpp
#include <iostream>

int main() {
    int num = 10;
    
    int& ricxvi = num;
    
    ricxvi++;
    
    // დაბეჭდავს 11-ს
    std::cout << num << std::endl;

}
```

რეფერენსების მთავარი ძალა მდგომარეობს იმაში თუ როგორ ვიყენებთ მათ ფუნქციებში
პარამეტრების გადასაცემად.

განვიხილოთ ესეთი მაგალითი:

```cpp
#include <iostream>

void modify(int x) {
    x++;
}

int main() {
    int num = 10;
    modify(num);
    // დაბეჭდავს 10-ს
    std::cout << num << std::endl;
}

```
მაგრამ თუ ფუნქციას ჩვენ პარამეტრს რეფერენსით გადავცემთ:

```cpp
#include <iostream>

void modify(int& x) {
    x++;
}

int main() {
    int num = 10;
    modify(num);
    // დაბეჭდავს 11-ს
    std::cout << num << std::endl;
}

```

# 7. გამოსახულება






